package it.vige.ws.utils;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;

import org.alfresco.model.ContentModel;
import org.alfresco.repo.content.MimetypeMap;
import org.alfresco.service.cmr.model.FileFolderService;
import org.alfresco.service.cmr.model.FileInfo;
import org.alfresco.service.cmr.repository.ContentService;
import org.alfresco.service.cmr.repository.ContentWriter;
import org.alfresco.service.cmr.repository.NodeRef;
import org.alfresco.service.cmr.repository.NodeService;
import org.alfresco.service.cmr.repository.StoreRef;
import org.alfresco.service.cmr.search.ResultSet;
import org.alfresco.service.cmr.search.SearchService;
import org.alfresco.service.namespace.QName;
import org.alfresco.util.ISO9075;
import org.apache.log4j.Logger;
import org.apache.pdfbox.exceptions.COSVisitorException;
import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;

import it.vige.ws.dom.VigeWSContentModel;

public class GenerationUtils {

	private Logger logger = Logger.getLogger(GenerationUtils.class);

	private SearchService searchService;
	private FileFolderService fileFolderService;
	private ContentService contentService;
	private NodeService nodeService;

	private String modelliGenPath;
	private String modelliRootPath;
	private String questionsPath;
	private String modelliDroolsPath;

	private String autoGeneratedName;
	private String xmlEnvelope;

	/**
	 * 
	 * @param pdfSecret
	 * @param templateOs
	 * @param nomeFile
	 * @return
	 * @throws IOException
	 * @throws COSVisitorException
	 */
	public InputStream convertToPdf(String nomeFile) throws IOException, COSVisitorException {

		DateTime startConversionTime = new DateTime();
		logger.info("Start conversion in pdf: " + startConversionTime.toString(DateTimeFormat.fullTime()));

		InputStream pdfInputStream = getClass().getClassLoader().getResourceAsStream("docs/" + nomeFile + ".pdf");

		return pdfInputStream;

	}

	/**
	 * 
	 * @param idPartner
	 * @param idPratica
	 * @param model
	 * @return
	 * @throws NoSuchElementException
	 */
	public NodeRef getTemplate(String idPartner, String idPratica, String model) throws NoSuchElementException {
		NodeRef modelloNR;

		// the model must first be searched in the client's folders.
		StringBuilder rootQuerySpec = new StringBuilder("PATH:\"").append(modelliRootPath).append("/cm:")
				.append(ISO9075.encode(idPartner)).append("/cm:").append(ISO9075.encode(idPratica))
				.append("/*\" AND (=@cm\\:name:\"").append(model).append(".docx\")");

		ResultSet modelliSpecRS = searchService.query(StoreRef.STORE_REF_WORKSPACE_SPACESSTORE,
				SearchService.LANGUAGE_FTS_ALFRESCO, rootQuerySpec.toString());

		if (modelliSpecRS.length() < 1) {
			logger.warn("Specific model not found");

			// if no specific model exists, the generic model must be returned.
			StringBuilder rootQueryGeneric = new StringBuilder("PATH:\"").append(modelliGenPath)
					.append("/*\" AND (=@cm\\:name:\"").append(model).append(".docx\")");

			ResultSet modelliGenRS = searchService.query(StoreRef.STORE_REF_WORKSPACE_SPACESSTORE,
					SearchService.LANGUAGE_FTS_ALFRESCO, rootQueryGeneric.toString());

			if (modelliGenRS.length() < 1) {
				// the requested model does not exist ... an error is returned
				logger.error("Generic model not found " + model);
				throw new NoSuchElementException();
			} else {
				modelloNR = modelliGenRS.getNodeRef(0);
			}
		} else {
			modelloNR = modelliSpecRS.getNodeRef(0);
		}
		return modelloNR;
	}

	/**
	 * Method for recovering the Autogenerated folder
	 * 
	 * @param idPartner
	 * @param idPratica
	 * @param annoCreazione
	 * @param meseCreazione
	 * @param json
	 * @return
	 * @throws NoSuchElementException
	 */
	public NodeRef getDestinazioneNodeRef(String idPartner, String idPratica, String annoCreazione,
			String meseCreazione, JSONObject json) throws NoSuchElementException {

		// Check if the Questions folder exists ...
		String rootQuery = "PATH:\"" + questionsPath + "\"";
		ResultSet siteRS = searchService.query(StoreRef.STORE_REF_WORKSPACE_SPACESSTORE,
				SearchService.LANGUAGE_FTS_ALFRESCO, rootQuery);

		// The Questions folder must exist
		if (siteRS.length() != 1) {
			throw new NoSuchElementException("The questions folder does not exist");
		}

		NodeRef siteDLNR = siteRS.getNodeRef(0);

		List<String> foldersToSearch = new ArrayList<>();
		foldersToSearch.add(idPartner);
		foldersToSearch.add(annoCreazione);
		foldersToSearch.add(meseCreazione);
		foldersToSearch.add(idPratica);
		foldersToSearch.add(autoGeneratedName);

		NodeRef currentParentNodeRef = siteDLNR;

		// eventually create all the folders of the new path
		for (String currentChildFolder : foldersToSearch) {

			NodeRef currentFolderNodeRef = fileFolderService.searchSimple(currentParentNodeRef, currentChildFolder);

			// it the path doesn't exist, it will be created
			if (currentFolderNodeRef == null) {
				FileInfo fi = fileFolderService.create(currentParentNodeRef, currentChildFolder,
						ContentModel.TYPE_FOLDER);
				currentParentNodeRef = fi.getNodeRef();
			} else {
				currentParentNodeRef = currentFolderNodeRef;
			}
		}

		return currentParentNodeRef;
	}

	/**
	 * 
	 * @param destinazioneNodeRef
	 * @param docName
	 * @param conversionResult
	 * @param props
	 */
	public void saveDocument(NodeRef destinazioneNodeRef, String docName, InputStream conversionResult,
			Map<QName, Serializable> props) {

		final FileInfo nodeFI = fileFolderService.create(destinazioneNodeRef, docName, ContentModel.TYPE_CONTENT);
		final ContentWriter writer = contentService.getWriter(nodeFI.getNodeRef(), ContentModel.PROP_CONTENT, true);
		writer.setMimetype(MimetypeMap.MIMETYPE_PDF);
		writer.guessEncoding();
		writer.putContent(conversionResult);

		// Adds the look for the description
		nodeService.addAspect(nodeFI.getNodeRef(), ContentModel.ASPECT_TITLED, new HashMap<QName, Serializable>());
		// adds the aspect for the metadata
		nodeService.addAspect(nodeFI.getNodeRef(), VigeWSContentModel.DOC_ASPECT, props);

		logger.info("document saved successfully");
	}

	/**
	 * 
	 * @param path
	 * @param model
	 * @return
	 * @throws NoSuchElementException
	 */
	public NodeRef getRegolaDrools(String model) throws NoSuchElementException {

		// the model must be found in the client's folders.
		StringBuilder rootQuerySpec = new StringBuilder("PATH:\"").append(modelliDroolsPath + "/*")
				.append("\" AND (=@cm\\:name:\"").append(model).append(".drl\")");

		ResultSet modelliSpecRS = searchService.query(StoreRef.STORE_REF_WORKSPACE_SPACESSTORE,
				SearchService.LANGUAGE_FTS_ALFRESCO, rootQuerySpec.toString());

		if (modelliSpecRS.length() < 1) {
			logger.error("Replacement rules file not found: " + model);
			modelliSpecRS.close();
			throw new NoSuchElementException("Replacement rules file not found: " + model);
		}

		return modelliSpecRS.getNodeRef(0);
	}

	/**
	 * It parses the json
	 * 
	 * @param codice
	 * @param json
	 * @return a key-value map with key = concatenation of the separate path by ':'
	 *         value
	 */
	@SuppressWarnings("unchecked")
	public Map<String, String> parseJsonObject(String codice, JSONObject json) {

		Map<String, String> parsedJsonResult = new HashMap<>();

		Set<String> keyset = json.keySet();

		for (String key : keyset) {

			String nuovoCodice = codice + ":" + key;

			Object obj = json.get(key);
			if (obj instanceof JSONObject) {
				// Recursive step
				Map<String, String> parsedJson = parseJsonObject(nuovoCodice, (JSONObject) obj);
				parsedJsonResult.putAll(parsedJson);
			} else if (obj instanceof JSONArray) {
				// Recursive step
				JSONArray valueArray = (JSONArray) obj;
				parseJsonArray(nuovoCodice, valueArray);
			} else if (obj instanceof String) {
				// Base step
				parsedJsonResult.put(nuovoCodice, (String) obj);
			}
		}

		return parsedJsonResult;
	}

	/**
	 * 
	 * @param codice
	 * @param jsonArray
	 * @return
	 */
	public Map<String, String> parseJsonArray(String codice, JSONArray jsonArray) {
		Map<String, String> parsedJsonResult = new HashMap<>();

		for (Object obj : jsonArray) {

			if (obj instanceof JSONObject) {
				Map<String, String> parsedJson = parseJsonObject(codice, (JSONObject) obj);
				parsedJsonResult.putAll(parsedJson);
			} else if (obj instanceof JSONArray) {
				parseJsonArray(codice, (JSONArray) obj);
			} else if (obj instanceof String) {
				// Base step
				parsedJsonResult.put(codice, (String) obj);
			}
		}

		return parsedJsonResult;
	}

	public SearchService getSearchService() {
		return searchService;
	}

	public void setSearchService(SearchService searchService) {
		this.searchService = searchService;
	}

	public FileFolderService getFileFolderService() {
		return fileFolderService;
	}

	public void setFileFolderService(FileFolderService fileFolderService) {
		this.fileFolderService = fileFolderService;
	}

	public ContentService getContentService() {
		return contentService;
	}

	public void setContentService(ContentService contentService) {
		this.contentService = contentService;
	}

	public NodeService getNodeService() {
		return nodeService;
	}

	public void setNodeService(NodeService nodeService) {
		this.nodeService = nodeService;
	}

	public String getModelliGenPath() {
		return modelliGenPath;
	}

	public void setModelliGenPath(String modelliGenPath) {
		this.modelliGenPath = modelliGenPath;
	}

	public String getModelliRootPath() {
		return modelliRootPath;
	}

	public void setModelliRootPath(String modelliRootPath) {
		this.modelliRootPath = modelliRootPath;
	}

	public String getQuestionsPath() {
		return questionsPath;
	}

	public void setQuestionsPath(String questionsPath) {
		this.questionsPath = questionsPath;
	}

	public String getModelliDroolsPath() {
		return modelliDroolsPath;
	}

	public void setModelliDroolsPath(String modelliDroolsPath) {
		this.modelliDroolsPath = modelliDroolsPath;
	}

	public String getAutoGeneratedName() {
		return autoGeneratedName;
	}

	public void setAutoGeneratedName(String autoGeneratedName) {
		this.autoGeneratedName = autoGeneratedName;
	}

	public String getXmlEnvelope() {
		return xmlEnvelope;
	}

	public void setXmlEnvelope(String xmlEnvelope) {
		this.xmlEnvelope = xmlEnvelope;
	}
}
