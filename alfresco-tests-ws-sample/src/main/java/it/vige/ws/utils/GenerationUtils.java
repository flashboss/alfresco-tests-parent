package it.vige.ws.utils;

import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;

import org.alfresco.model.ContentModel;
import org.alfresco.repo.content.MimetypeMap;
import org.alfresco.service.cmr.model.FileFolderService;
import org.alfresco.service.cmr.model.FileInfo;
import org.alfresco.service.cmr.repository.ContentService;
import org.alfresco.service.cmr.repository.ContentWriter;
import org.alfresco.service.cmr.repository.NodeRef;
import org.alfresco.service.cmr.repository.NodeService;
import org.alfresco.service.cmr.repository.StoreRef;
import org.alfresco.service.cmr.search.ResultSet;
import org.alfresco.service.cmr.search.SearchService;
import org.alfresco.service.namespace.QName;
import org.alfresco.util.ISO9075;
import org.apache.log4j.Logger;
import org.apache.pdfbox.exceptions.COSVisitorException;
import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;

import it.vige.ws.dom.VigeWSContentModel;

/**
 * Utility class for document generation operations.
 * Provides methods for template retrieval, PDF conversion and document saving.
 *
 * @author lucastancapiano
 */
public class GenerationUtils {

	/** The logger instance. */
	private Logger logger = Logger.getLogger(GenerationUtils.class);

	/** The search service. */
	private SearchService searchService;

	/** The file folder service. */
	private FileFolderService fileFolderService;

	/** The content service. */
	private ContentService contentService;

	/** The node service. */
	private NodeService nodeService;

	/** The path to generic templates. */
	private String modelliGenPath;

	/** The root path for templates. */
	private String modelliRootPath;

	/** The path to questions folder. */
	private String questionsPath;

	/** The path to Drools rules. */
	private String modelliDroolsPath;

	/** The name for auto-generated folder. */
	private String autoGeneratedName;

	/** The XML envelope content. */
	private String xmlEnvelope;

	/**
	 * Converts a document to PDF format.
	 *
	 * @param nomeFile the file name to convert
	 * @return the input stream containing the PDF content
	 * @throws IOException if an I/O error occurs
	 * @throws COSVisitorException if a PDF processing error occurs
	 */
	public InputStream convertToPdf(String nomeFile) throws IOException, COSVisitorException {
		DateTime startConversionTime = new DateTime();
		logger.info("Start conversion in pdf: " + startConversionTime.toString(DateTimeFormat.fullTime()));
		InputStream pdfInputStream = getClass().getClassLoader().getResourceAsStream("docs/" + nomeFile + ".pdf");
		return pdfInputStream;
	}

	/**
	 * Retrieves a template by partner ID, practice ID, and model name.
	 *
	 * @param idPartner the partner ID
	 * @param idPratica the practice ID
	 * @param model the model/template name
	 * @return the node reference to the template
	 * @throws NoSuchElementException if the template is not found
	 */
	public NodeRef getTemplate(String idPartner, String idPratica, String model) throws NoSuchElementException {
		NodeRef modelloNR;
		StringBuilder rootQuerySpec = new StringBuilder("PATH:\"").append(modelliRootPath).append("/cm:")
				.append(ISO9075.encode(idPartner)).append("/cm:").append(ISO9075.encode(idPratica))
				.append("/*\" AND (=@cm\\:name:\"").append(model).append(".docx\")");
		ResultSet modelliSpecRS = searchService.query(StoreRef.STORE_REF_WORKSPACE_SPACESSTORE,
				SearchService.LANGUAGE_FTS_ALFRESCO, rootQuerySpec.toString());
		if (modelliSpecRS.length() < 1) {
			logger.warn("Specific model not found");
			StringBuilder rootQueryGeneric = new StringBuilder("PATH:\"").append(modelliGenPath)
					.append("/*\" AND (=@cm\\:name:\"").append(model).append(".docx\")");
			ResultSet modelliGenRS = searchService.query(StoreRef.STORE_REF_WORKSPACE_SPACESSTORE,
					SearchService.LANGUAGE_FTS_ALFRESCO, rootQueryGeneric.toString());
			if (modelliGenRS.length() < 1) {
				logger.error("Generic model not found " + model);
				throw new NoSuchElementException();
			} else {
				modelloNR = modelliGenRS.getNodeRef(0);
			}
		} else {
			modelloNR = modelliSpecRS.getNodeRef(0);
		}
		return modelloNR;
	}

	/**
	 * Gets or creates the destination folder for auto-generated documents.
	 *
	 * @param idPartner the partner ID
	 * @param idPratica the practice ID
	 * @param annoCreazione the creation year
	 * @param meseCreazione the creation month
	 * @param json the JSON object containing additional data
	 * @return the node reference to the destination folder
	 * @throws NoSuchElementException if the questions folder does not exist
	 */
	public NodeRef getDestinazioneNodeRef(String idPartner, String idPratica, String annoCreazione,
			String meseCreazione, JSONObject json) throws NoSuchElementException {
		String rootQuery = "PATH:\"" + questionsPath + "\"";
		ResultSet siteRS = searchService.query(StoreRef.STORE_REF_WORKSPACE_SPACESSTORE,
				SearchService.LANGUAGE_FTS_ALFRESCO, rootQuery);
		if (siteRS.length() != 1) {
			throw new NoSuchElementException("The questions folder does not exist");
		}
		NodeRef siteDLNR = siteRS.getNodeRef(0);
		List<String> foldersToSearch = new ArrayList<>();
		foldersToSearch.add(idPartner);
		foldersToSearch.add(annoCreazione);
		foldersToSearch.add(meseCreazione);
		foldersToSearch.add(idPratica);
		foldersToSearch.add(autoGeneratedName);
		NodeRef currentParentNodeRef = siteDLNR;
		for (String currentChildFolder : foldersToSearch) {
			NodeRef currentFolderNodeRef = fileFolderService.searchSimple(currentParentNodeRef, currentChildFolder);
			if (currentFolderNodeRef == null) {
				FileInfo fi = fileFolderService.create(currentParentNodeRef, currentChildFolder,
						ContentModel.TYPE_FOLDER);
				currentParentNodeRef = fi.getNodeRef();
			} else {
				currentParentNodeRef = currentFolderNodeRef;
			}
		}
		return currentParentNodeRef;
	}

	/**
	 * Saves a document to the repository with the specified properties.
	 *
	 * @param destinazioneNodeRef the destination folder node reference
	 * @param docName the document name
	 * @param conversionResult the input stream containing the document content
	 * @param props the properties to set on the document
	 */
	public void saveDocument(NodeRef destinazioneNodeRef, String docName, InputStream conversionResult,
			Map<QName, Serializable> props) {
		final FileInfo nodeFI = fileFolderService.create(destinazioneNodeRef, docName, ContentModel.TYPE_CONTENT);
		final ContentWriter writer = contentService.getWriter(nodeFI.getNodeRef(), ContentModel.PROP_CONTENT, true);
		writer.setMimetype(MimetypeMap.MIMETYPE_PDF);
		writer.guessEncoding();
		writer.putContent(conversionResult);
		nodeService.addAspect(nodeFI.getNodeRef(), ContentModel.ASPECT_TITLED, new HashMap<QName, Serializable>());
		nodeService.addAspect(nodeFI.getNodeRef(), VigeWSContentModel.DOC_ASPECT, props);
		logger.info("document saved successfully");
	}

	/**
	 * Retrieves the Drools rule file for a given model.
	 *
	 * @param model the model name
	 * @return the node reference to the Drools rule file
	 * @throws NoSuchElementException if the rule file is not found
	 */
	public NodeRef getRegolaDrools(String model) throws NoSuchElementException {
		StringBuilder rootQuerySpec = new StringBuilder("PATH:\"").append(modelliDroolsPath + "/*")
				.append("\" AND (=@cm\\:name:\"").append(model).append(".drl\")");
		ResultSet modelliSpecRS = searchService.query(StoreRef.STORE_REF_WORKSPACE_SPACESSTORE,
				SearchService.LANGUAGE_FTS_ALFRESCO, rootQuerySpec.toString());
		if (modelliSpecRS.length() < 1) {
			logger.error("Replacement rules file not found: " + model);
			modelliSpecRS.close();
			throw new NoSuchElementException("Replacement rules file not found: " + model);
		}
		return modelliSpecRS.getNodeRef(0);
	}

	/**
	 * Parses a JSON object recursively into a key-value map.
	 *
	 * @param codice the current path code
	 * @param json the JSON object to parse
	 * @return a map with concatenated path keys and string values
	 */
	@SuppressWarnings("unchecked")
	public Map<String, String> parseJsonObject(String codice, JSONObject json) {
		Map<String, String> parsedJsonResult = new HashMap<>();
		Set<String> keyset = json.keySet();
		for (String key : keyset) {
			String nuovoCodice = codice + ":" + key;
			Object obj = json.get(key);
			if (obj instanceof JSONObject) {
				Map<String, String> parsedJson = parseJsonObject(nuovoCodice, (JSONObject) obj);
				parsedJsonResult.putAll(parsedJson);
			} else if (obj instanceof JSONArray) {
				JSONArray valueArray = (JSONArray) obj;
				parseJsonArray(nuovoCodice, valueArray);
			} else if (obj instanceof String) {
				parsedJsonResult.put(nuovoCodice, (String) obj);
			}
		}
		return parsedJsonResult;
	}

	/**
	 * Parses a JSON array recursively into a key-value map.
	 *
	 * @param codice the current path code
	 * @param jsonArray the JSON array to parse
	 * @return a map with concatenated path keys and string values
	 */
	public Map<String, String> parseJsonArray(String codice, JSONArray jsonArray) {
		Map<String, String> parsedJsonResult = new HashMap<>();
		for (Object obj : jsonArray) {
			if (obj instanceof JSONObject) {
				Map<String, String> parsedJson = parseJsonObject(codice, (JSONObject) obj);
				parsedJsonResult.putAll(parsedJson);
			} else if (obj instanceof JSONArray) {
				parseJsonArray(codice, (JSONArray) obj);
			} else if (obj instanceof String) {
				parsedJsonResult.put(codice, (String) obj);
			}
		}
		return parsedJsonResult;
	}

	/**
	 * Gets the search service.
	 *
	 * @return the search service
	 */
	public SearchService getSearchService() {
		return searchService;
	}

	/**
	 * Sets the search service.
	 *
	 * @param searchService the search service to set
	 */
	public void setSearchService(SearchService searchService) {
		this.searchService = searchService;
	}

	/**
	 * Gets the file folder service.
	 *
	 * @return the file folder service
	 */
	public FileFolderService getFileFolderService() {
		return fileFolderService;
	}

	/**
	 * Sets the file folder service.
	 *
	 * @param fileFolderService the file folder service to set
	 */
	public void setFileFolderService(FileFolderService fileFolderService) {
		this.fileFolderService = fileFolderService;
	}

	/**
	 * Gets the content service.
	 *
	 * @return the content service
	 */
	public ContentService getContentService() {
		return contentService;
	}

	/**
	 * Sets the content service.
	 *
	 * @param contentService the content service to set
	 */
	public void setContentService(ContentService contentService) {
		this.contentService = contentService;
	}

	/**
	 * Gets the node service.
	 *
	 * @return the node service
	 */
	public NodeService getNodeService() {
		return nodeService;
	}

	/**
	 * Sets the node service.
	 *
	 * @param nodeService the node service to set
	 */
	public void setNodeService(NodeService nodeService) {
		this.nodeService = nodeService;
	}

	/**
	 * Gets the generic templates path.
	 *
	 * @return the generic templates path
	 */
	public String getModelliGenPath() {
		return modelliGenPath;
	}

	/**
	 * Sets the generic templates path.
	 *
	 * @param modelliGenPath the generic templates path to set
	 */
	public void setModelliGenPath(String modelliGenPath) {
		this.modelliGenPath = modelliGenPath;
	}

	/**
	 * Gets the templates root path.
	 *
	 * @return the templates root path
	 */
	public String getModelliRootPath() {
		return modelliRootPath;
	}

	/**
	 * Sets the templates root path.
	 *
	 * @param modelliRootPath the templates root path to set
	 */
	public void setModelliRootPath(String modelliRootPath) {
		this.modelliRootPath = modelliRootPath;
	}

	/**
	 * Gets the questions path.
	 *
	 * @return the questions path
	 */
	public String getQuestionsPath() {
		return questionsPath;
	}

	/**
	 * Sets the questions path.
	 *
	 * @param questionsPath the questions path to set
	 */
	public void setQuestionsPath(String questionsPath) {
		this.questionsPath = questionsPath;
	}

	/**
	 * Gets the Drools templates path.
	 *
	 * @return the Drools templates path
	 */
	public String getModelliDroolsPath() {
		return modelliDroolsPath;
	}

	/**
	 * Sets the Drools templates path.
	 *
	 * @param modelliDroolsPath the Drools templates path to set
	 */
	public void setModelliDroolsPath(String modelliDroolsPath) {
		this.modelliDroolsPath = modelliDroolsPath;
	}

	/**
	 * Gets the auto-generated folder name.
	 *
	 * @return the auto-generated folder name
	 */
	public String getAutoGeneratedName() {
		return autoGeneratedName;
	}

	/**
	 * Sets the auto-generated folder name.
	 *
	 * @param autoGeneratedName the auto-generated folder name to set
	 */
	public void setAutoGeneratedName(String autoGeneratedName) {
		this.autoGeneratedName = autoGeneratedName;
	}

	/**
	 * Gets the XML envelope.
	 *
	 * @return the XML envelope
	 */
	public String getXmlEnvelope() {
		return xmlEnvelope;
	}

	/**
	 * Sets the XML envelope.
	 *
	 * @param xmlEnvelope the XML envelope to set
	 */
	public void setXmlEnvelope(String xmlEnvelope) {
		this.xmlEnvelope = xmlEnvelope;
	}
}
