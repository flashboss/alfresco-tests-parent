package it.vige.ws.utils;

import it.vige.ws.dom.VigeWSContentModel;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import okhttp3.MediaType;
import okhttp3.MultipartBody;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;
import org.alfresco.model.ContentModel;
import org.alfresco.repo.content.MimetypeMap;
import org.alfresco.service.cmr.model.FileFolderService;
import org.alfresco.service.cmr.model.FileInfo;
import org.alfresco.service.cmr.repository.ContentService;
import org.alfresco.service.cmr.repository.ContentWriter;
import org.alfresco.service.cmr.repository.NodeRef;
import org.alfresco.service.cmr.repository.NodeService;
import org.alfresco.service.cmr.repository.StoreRef;
import org.alfresco.service.cmr.search.ResultSet;
import org.alfresco.service.cmr.search.SearchService;
import org.alfresco.service.namespace.QName;
import org.alfresco.util.ISO9075;
import org.apache.commons.codec.binary.Base64;
import org.apache.log4j.Logger;
import org.apache.pdfbox.exceptions.COSVisitorException;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.PDDocumentInformation;
import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.springframework.extensions.webscripts.WebScriptException;

/**
 * Utility class providing helper methods.
 *
 * @author vige
 */
public class GenerationUtils {

  private Logger logger = Logger.getLogger(GenerationUtils.class);

  private SearchService searchService;
  private FileFolderService fileFolderService;
  private ContentService contentService;
  private NodeService nodeService;

  private String modelliGenPath;
  private String modelliRootPath;
  private String questionsPath;
  private String modelliDroolsPath;

  private String autoGeneratedName;
  private String xmlEnvelope;

  /**
   * @param pdfSecret
   * @param templateOs
   * @param nomeFile
   * @return
   * @throws IOException
   * @throws COSVisitorException
   */
  public InputStream convertToPdf(
      String pdfSecret, ByteArrayOutputStream templateOs, String nomeFile)
      throws IOException, COSVisitorException {

    // Conversion in PDF via Webservice
    String srcFormat = "docx";
    String dstFormat = "pdf";
    String authParam = String.format("Secret=%s", pdfSecret);
    String convertMetadataParam = String.format("&ConvertMetadata=%s", true);

    byte[] toConvertByteArray = templateOs.toByteArray();

    RequestBody formBody =
        new MultipartBody.Builder()
            .setType(MultipartBody.FORM)
            .addFormDataPart(
                "file",
                "file1.docx",
                RequestBody.create(MediaType.parse("application/octet-stream"), toConvertByteArray))
            .addFormDataPart("Secret", pdfSecret)
            .build();

    Request request =
        new Request.Builder()
            .url(
                String.format(
                    "https://v2.convertapi.com/%s/to/%s?%s%s",
                    srcFormat, dstFormat, authParam, convertMetadataParam))
            .post(formBody)
            .build();

    JSONObject jsonObject;

    OkHttpClient client =
        new OkHttpClient.Builder()
            .connectTimeout(30, TimeUnit.SECONDS)
            .writeTimeout(30, TimeUnit.SECONDS)
            .readTimeout(60, TimeUnit.SECONDS)
            .build(); // socket timeout

    DateTime startConversionTime = new DateTime();
    logger.info(
        "Start conversion in pdf: " + startConversionTime.toString(DateTimeFormat.fullTime()));

    try (Response response = client.newCall(request).execute()) {

      int status = response.code();

      try (ResponseBody body = response.body()) {
        byte[] responseBody = body.bytes();
        StringReader jsonReader = new StringReader(new String(responseBody));
        JSONParser jsonParser = new JSONParser();
        jsonObject = (JSONObject) jsonParser.parse(jsonReader);
      }

      if (status != 200) {
        logger.error(jsonObject.toString());
        throw new WebScriptException(
            "Errore nella chiamata di conversione in pdf - status: " + status);
      }

      logger.info("End conversion in pdf: " + new DateTime().toString(DateTimeFormat.fullTime()));
    } catch (Exception e) {
      logger.error("Error conversion in pdf " + e.getMessage());
      logger.error("End conversion in pdf: " + new DateTime().toString(DateTimeFormat.fullTime()));
      throw new WebScriptException("Error conversion in pdf");
    }

    JSONArray fileArray = (JSONArray) jsonObject.get("Files");
    JSONObject fileJsonObj = (JSONObject) fileArray.get(0);
    String base64FileData = (String) fileJsonObj.get("FileData");

    Base64 base64Decoder = new Base64();

    byte[] decodedPdf = base64Decoder.decode(base64FileData);

    InputStream pdfInputStream = setPDFMetadata(new ByteArrayInputStream(decodedPdf));

    return pdfInputStream;
  }

  /**
   * @param idPartner
   * @param idPratica
   * @param model
   * @return
   * @throws NoSuchElementException
   */
  public NodeRef getTemplate(String idPartner, String idPratica, String model)
      throws NoSuchElementException {
    NodeRef modelloNR;

    // the model must first be searched in the client's folders.
    StringBuilder rootQuerySpec =
        new StringBuilder("PATH:\"")
            .append(modelliRootPath)
            .append("/cm:")
            .append(ISO9075.encode(idPartner))
            .append("/cm:")
            .append(ISO9075.encode(idPratica))
            .append("/*\" AND (=@cm\\:name:\"")
            .append(model)
            .append(".docx\")");

    ResultSet modelliSpecRS =
        searchService.query(
            StoreRef.STORE_REF_WORKSPACE_SPACESSTORE,
            SearchService.LANGUAGE_FTS_ALFRESCO,
            rootQuerySpec.toString());

    if (modelliSpecRS.length() < 1) {
      logger.warn("Specific model not found");

      // if no specific model exists, the generic model must be returned.
      StringBuilder rootQueryGeneric =
          new StringBuilder("PATH:\"")
              .append(modelliGenPath)
              .append("/*\" AND (=@cm\\:name:\"")
              .append(model)
              .append(".docx\")");

      ResultSet modelliGenRS =
          searchService.query(
              StoreRef.STORE_REF_WORKSPACE_SPACESSTORE,
              SearchService.LANGUAGE_FTS_ALFRESCO,
              rootQueryGeneric.toString());

      if (modelliGenRS.length() < 1) {
        // the requested model does not exist ... an error is returned
        logger.error("Generic model not found " + model);
        throw new NoSuchElementException();
      } else {
        modelloNR = modelliGenRS.getNodeRef(0);
      }
    } else {
      modelloNR = modelliSpecRS.getNodeRef(0);
    }
    return modelloNR;
  }

  /**
   * Method for recovering the Autogenerated folder
   *
   * @param idPartner
   * @param idPratica
   * @param annoCreazione
   * @param meseCreazione
   * @param json
   * @return
   * @throws NoSuchElementException
   */
  public NodeRef getDestinazioneNodeRef(
      String idPartner,
      String idPratica,
      String annoCreazione,
      String meseCreazione,
      JSONObject json)
      throws NoSuchElementException {

    // Check if the Questions folder exists ...
    String rootQuery = "PATH:\"" + questionsPath + "\"";
    ResultSet siteRS =
        searchService.query(
            StoreRef.STORE_REF_WORKSPACE_SPACESSTORE,
            SearchService.LANGUAGE_FTS_ALFRESCO,
            rootQuery);

    // The Questions folder must exist
    if (siteRS.length() != 1) {
      throw new NoSuchElementException("The questions folder does not exist");
    }

    NodeRef siteDLNR = siteRS.getNodeRef(0);

    List<String> foldersToSearch = new ArrayList<>();
    foldersToSearch.add(idPartner);
    foldersToSearch.add(annoCreazione);
    foldersToSearch.add(meseCreazione);
    foldersToSearch.add(idPratica);
    foldersToSearch.add(autoGeneratedName);

    NodeRef currentParentNodeRef = siteDLNR;

    // eventually create all the folders of the new path
    for (String currentChildFolder : foldersToSearch) {

      NodeRef currentFolderNodeRef =
          fileFolderService.searchSimple(currentParentNodeRef, currentChildFolder);

      // it the path doesn't exist, it will be created
      if (currentFolderNodeRef == null) {
        FileInfo fi =
            fileFolderService.create(
                currentParentNodeRef, currentChildFolder, ContentModel.TYPE_FOLDER);
        currentParentNodeRef = fi.getNodeRef();
      } else {
        currentParentNodeRef = currentFolderNodeRef;
      }
    }

    return currentParentNodeRef;
  }

  /**
   * @param destinazioneNodeRef
   * @param docName
   * @param conversionResult
   * @param props
   */
  public void saveDocument(
      NodeRef destinazioneNodeRef,
      String docName,
      InputStream conversionResult,
      Map<QName, Serializable> props) {

    final FileInfo nodeFI =
        fileFolderService.create(destinazioneNodeRef, docName, ContentModel.TYPE_CONTENT);
    final ContentWriter writer =
        contentService.getWriter(nodeFI.getNodeRef(), ContentModel.PROP_CONTENT, true);
    writer.setMimetype(MimetypeMap.MIMETYPE_PDF);
    writer.guessEncoding();
    writer.putContent(conversionResult);

    // Adds the look for the description
    nodeService.addAspect(
        nodeFI.getNodeRef(), ContentModel.ASPECT_TITLED, new HashMap<QName, Serializable>());
    // adds the aspect for the metadata
    nodeService.addAspect(nodeFI.getNodeRef(), VigeWSContentModel.DOC_ASPECT, props);

    logger.info("document saved successfully");
  }

  /**
   * @param path
   * @param model
   * @return
   * @throws NoSuchElementException
   */
  public NodeRef getRegolaDrools(String model) throws NoSuchElementException {

    // the model must be found in the client's folders.
    StringBuilder rootQuerySpec =
        new StringBuilder("PATH:\"")
            .append(modelliDroolsPath + "/*")
            .append("\" AND (=@cm\\:name:\"")
            .append(model)
            .append(".drl\")");

    ResultSet modelliSpecRS =
        searchService.query(
            StoreRef.STORE_REF_WORKSPACE_SPACESSTORE,
            SearchService.LANGUAGE_FTS_ALFRESCO,
            rootQuerySpec.toString());

    if (modelliSpecRS.length() < 1) {
      logger.error("Replacement rules file not found: " + model);
      modelliSpecRS.close();
      throw new NoSuchElementException("Replacement rules file not found: " + model);
    }

    return modelliSpecRS.getNodeRef(0);
  }

  /**
   * It parses the json
   *
   * @param codice
   * @param json
   * @return a key-value map with key = concatenation of the separate path by ':' value
   */
  @SuppressWarnings("unchecked")
  public Map<String, String> parseJsonObject(String codice, JSONObject json) {

    Map<String, String> parsedJsonResult = new HashMap<>();

    Set<String> keyset = json.keySet();

    for (String key : keyset) {

      String nuovoCodice = codice + ":" + key;

      Object obj = json.get(key);
      if (obj instanceof JSONObject) {
        // Recursive step
        Map<String, String> parsedJson = parseJsonObject(nuovoCodice, (JSONObject) obj);
        parsedJsonResult.putAll(parsedJson);
      } else if (obj instanceof JSONArray) {
        // Recursive step
        JSONArray valueArray = (JSONArray) obj;
        parseJsonArray(nuovoCodice, valueArray);
      } else if (obj instanceof String) {
        // Base step
        parsedJsonResult.put(nuovoCodice, (String) obj);
      }
    }

    return parsedJsonResult;
  }

  /**
   * @param codice
   * @param jsonArray
   * @return
   */
  public Map<String, String> parseJsonArray(String codice, JSONArray jsonArray) {
    Map<String, String> parsedJsonResult = new HashMap<>();

    for (Object obj : jsonArray) {

      if (obj instanceof JSONObject) {
        Map<String, String> parsedJson = parseJsonObject(codice, (JSONObject) obj);
        parsedJsonResult.putAll(parsedJson);
      } else if (obj instanceof JSONArray) {
        parseJsonArray(codice, (JSONArray) obj);
      } else if (obj instanceof String) {
        // Base step
        parsedJsonResult.put(codice, (String) obj);
      }
    }

    return parsedJsonResult;
  }

  /**
   * @param pdfStream
   * @return
   * @throws IOException
   * @throws COSVisitorException
   */
  private InputStream setPDFMetadata(InputStream pdfStream)
      throws IOException, COSVisitorException {

    PDDocument doc = PDDocument.load(pdfStream);
    PDDocumentInformation info = doc.getDocumentInformation();

    info.setProducer("Sample Bank - http://www.vige.it/");

    doc.setDocumentInformation(info);

    ByteArrayOutputStream out = new ByteArrayOutputStream();

    doc.save(out);

    return new ByteArrayInputStream(out.toByteArray());
  }

  public SearchService getSearchService() {
    return searchService;
  }

  public void setSearchService(SearchService searchService) {
    this.searchService = searchService;
  }

  public FileFolderService getFileFolderService() {
    return fileFolderService;
  }

  public void setFileFolderService(FileFolderService fileFolderService) {
    this.fileFolderService = fileFolderService;
  }

  public ContentService getContentService() {
    return contentService;
  }

  public void setContentService(ContentService contentService) {
    this.contentService = contentService;
  }

  public NodeService getNodeService() {
    return nodeService;
  }

  public void setNodeService(NodeService nodeService) {
    this.nodeService = nodeService;
  }

  public String getModelliGenPath() {
    return modelliGenPath;
  }

  public void setModelliGenPath(String modelliGenPath) {
    this.modelliGenPath = modelliGenPath;
  }

  public String getModelliRootPath() {
    return modelliRootPath;
  }

  public void setModelliRootPath(String modelliRootPath) {
    this.modelliRootPath = modelliRootPath;
  }

  public String getQuestionsPath() {
    return questionsPath;
  }

  public void setQuestionsPath(String questionsPath) {
    this.questionsPath = questionsPath;
  }

  public String getModelliDroolsPath() {
    return modelliDroolsPath;
  }

  public void setModelliDroolsPath(String modelliDroolsPath) {
    this.modelliDroolsPath = modelliDroolsPath;
  }

  public String getAutoGeneratedName() {
    return autoGeneratedName;
  }

  public void setAutoGeneratedName(String autoGeneratedName) {
    this.autoGeneratedName = autoGeneratedName;
  }

  public String getXmlEnvelope() {
    return xmlEnvelope;
  }

  public void setXmlEnvelope(String xmlEnvelope) {
    this.xmlEnvelope = xmlEnvelope;
  }
}
