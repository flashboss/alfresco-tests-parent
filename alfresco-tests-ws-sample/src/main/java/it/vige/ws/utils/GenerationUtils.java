package it.vige.ws.utils;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.Serializable;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Set;
import java.util.concurrent.TimeUnit;

import org.alfresco.model.ContentModel;
import org.alfresco.repo.content.MimetypeMap;
import org.alfresco.service.cmr.model.FileFolderService;
import org.alfresco.service.cmr.model.FileInfo;
import org.alfresco.service.cmr.repository.ContentService;
import org.alfresco.service.cmr.repository.ContentWriter;
import org.alfresco.service.cmr.repository.NodeRef;
import org.alfresco.service.cmr.repository.NodeService;
import org.alfresco.service.cmr.repository.StoreRef;
import org.alfresco.service.cmr.search.ResultSet;
import org.alfresco.service.cmr.search.SearchService;
import org.alfresco.service.namespace.QName;
import org.alfresco.util.ISO9075;
import org.apache.commons.codec.binary.Base64;
import org.apache.log4j.Logger;
import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.PDDocumentInformation;
import org.joda.time.DateTime;
import org.joda.time.format.DateTimeFormat;
import org.json.simple.JSONArray;
import org.json.simple.JSONObject;
import org.json.simple.parser.JSONParser;
import org.springframework.extensions.webscripts.WebScriptException;

import it.vige.ws.dom.VigeWSContentModel;
import okhttp3.MediaType;
import okhttp3.MultipartBody;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;

/**
 * Utility class providing helper methods.
 * 
 * @author vige
 */
public class GenerationUtils {

 /**
 * Utility class providing helper methods.
 * 
 * @author vige
 */
	private Logger logger = Logger.getLogger(GenerationUtils.class);

 /**
 * Utility class providing helper methods.
 * 
 * @author vige
 */
	private SearchService searchService;
 /**
 * Utility class providing helper methods.
 * 
 * @author vige
 */
	private FileFolderService fileFolderService;
	private ContentService contentService;
	private NodeService nodeService;

	private String modelliGenPath;
	private String modelliRootPath;
	private String questionsPath;
	private String modelliDroolsPath;

	private String autoGeneratedName;
	private String xmlEnvelope;

	/**
	 * 
	 * @param pdfSecret
	 * @param templateOs
	 * @param nomeFile
	 * @return
	 * @throws IOException
	 * @throws COSVisitorException
	 */
	public InputStream convertToPdf(String pdfSecret, ByteArrayOutputStream templateOs, String nomeFile)
			throws IOException {

		// Conversion in PDF via Webservice
		String srcFormat = "docx";
		String dstFormat = "pdf";
		String authParam = String.format("Secret=%s", pdfSecret);
		String convertMetadataParam = String.format("&ConvertMetadata=%s", true);

		byte[] toConvertByteArray = templateOs.toByteArray();

		RequestBody formBody = new MultipartBody.Builder().setType(MultipartBody.FORM)
				.addFormDataPart("file", "file1.docx",
						RequestBody.create(MediaType.parse("application/octet-stream"), toConvertByteArray))
				.addFormDataPart("Secret", pdfSecret).build();

		Request request = new Request.Builder().url(String.format("https://v2.convertapi.com/%s/to/%s?%s%s", srcFormat,
				dstFormat, authParam, convertMetadataParam)).post(formBody).build();

		JSONObject jsonObject;

		OkHttpClient client = new OkHttpClient.Builder().connectTimeout(30, TimeUnit.SECONDS)
				.writeTimeout(30, TimeUnit.SECONDS).readTimeout(60, TimeUnit.SECONDS).build(); // socket timeout

		DateTime startConversionTime = new DateTime();
		logger.info("Start conversion in pdf: " + startConversionTime.toString(DateTimeFormat.fullTime()));

		try (Response response = client.newCall(request).execute()) {

			int status = response.code();

			try (ResponseBody body = response.body()) {
				byte[] responseBody = body.bytes();
				StringReader jsonReader = new StringReader(new String(responseBody));
				JSONParser jsonParser = new JSONParser();
				jsonObject = (JSONObject) jsonParser.parse(jsonReader);
			}

			if (status != 200) {
				logger.error(jsonObject.toString());
				throw new WebScriptException("Errore nella chiamata di conversione in pdf - status: " + status);
			}

			logger.info("End conversion in pdf: " + new DateTime().toString(DateTimeFormat.fullTime()));
		} catch (Exception e) {
			logger.error("Error conversion in pdf " + e.getMessage());
			logger.error("End conversion in pdf: " + new DateTime().toString(DateTimeFormat.fullTime()));
			throw new WebScriptException("Error conversion in pdf");
		}

		JSONArray fileArray = (JSONArray) jsonObject.get("Files");
		JSONObject fileJsonObj = (JSONObject) fileArray.get(0);
		String base64FileData = (String) fileJsonObj.get("FileData");

		Base64 base64Decoder = new Base64();

		byte[] decodedPdf = base64Decoder.decode(base64FileData);

		InputStream pdfInputStream = setPDFMetadata(new ByteArrayInputStream(decodedPdf));

		return pdfInputStream;

	}

	/**
	 * 
	 * @param idPartner
	 * @param idPratica
	 * @param model
	 * @return
	 * @throws NoSuchElementException
	 */
	public NodeRef getTemplate(String idPartner, String idPratica, String model) throws NoSuchElementException {
		NodeRef modelloNR;

		// the model must first be searched in the client's folders.
		StringBuilder rootQuerySpec = new StringBuilder("PATH:\"").append(modelliRootPath).append("/cm:")
				.append(ISO9075.encode(idPartner)).append("/cm:").append(ISO9075.encode(idPratica))
				.append("/*\" AND (=@cm\\:name:\"").append(model).append(".docx\")");

		ResultSet modelliSpecRS = searchService.query(StoreRef.STORE_REF_WORKSPACE_SPACESSTORE,
				SearchService.LANGUAGE_FTS_ALFRESCO, rootQuerySpec.toString());

		if (modelliSpecRS.length() < 1) {
			logger.warn("Specific model not found");

			// if no specific model exists, the generic model must be returned.
			StringBuilder rootQueryGeneric = new StringBuilder("PATH:\"").append(modelliGenPath)
					.append("/*\" AND (=@cm\\:name:\"").append(model).append(".docx\")");

			ResultSet modelliGenRS = searchService.query(StoreRef.STORE_REF_WORKSPACE_SPACESSTORE,
					SearchService.LANGUAGE_FTS_ALFRESCO, rootQueryGeneric.toString());

			if (modelliGenRS.length() < 1) {
				// the requested model does not exist ... an error is returned
				logger.error("Generic model not found " + model);
				throw new NoSuchElementException();
			} else {
				modelloNR = modelliGenRS.getNodeRef(0);
			}
		} else {
			modelloNR = modelliSpecRS.getNodeRef(0);
		}
		return modelloNR;
	}

	/**
	 * Method for recovering the Autogenerated folder
	 * 
	 * @param idPartner
	 * @param idPratica
	 * @param annoCreazione
	 * @param meseCreazione
	 * @param json
	 * @return
	 * @throws NoSuchElementException
	 */
	public NodeRef getDestinazioneNodeRef(String idPartner, String idPratica, String annoCreazione,
			String meseCreazione, JSONObject json) throws NoSuchElementException {

		// Check if the Questions folder exists ...
		String rootQuery = "PATH:\"" + questionsPath + "\"";
		ResultSet siteRS = searchService.query(StoreRef.STORE_REF_WORKSPACE_SPACESSTORE,
				SearchService.LANGUAGE_FTS_ALFRESCO, rootQuery);

		// The Questions folder must exist
		if (siteRS.length() != 1) {
			throw new NoSuchElementException("The questions folder does not exist");
		}

		NodeRef siteDLNR = siteRS.getNodeRef(0);

		List<String> foldersToSearch = new ArrayList<>();
		foldersToSearch.add(idPartner);
		foldersToSearch.add(annoCreazione);
		foldersToSearch.add(meseCreazione);
		foldersToSearch.add(idPratica);
		foldersToSearch.add(autoGeneratedName);

		NodeRef currentParentNodeRef = siteDLNR;

		// eventually create all the folders of the new path
		for (String currentChildFolder : foldersToSearch) {

			NodeRef currentFolderNodeRef = fileFolderService.searchSimple(currentParentNodeRef, currentChildFolder);

			// it the path doesn't exist, it will be created
			if (currentFolderNodeRef == null) {
				FileInfo fi = fileFolderService.create(currentParentNodeRef, currentChildFolder,
						ContentModel.TYPE_FOLDER);
				currentParentNodeRef = fi.getNodeRef();
			} else {
				currentParentNodeRef = currentFolderNodeRef;
			}
		}

		return currentParentNodeRef;
	}

	/**
	 * 
	 * @param destinazioneNodeRef
	 * @param docName
	 * @param conversionResult
	 * @param props
	 */
	public void saveDocument(NodeRef destinazioneNodeRef, String docName, InputStream conversionResult,
			Map<QName, Serializable> props) {

  /**
  * 
  * @param destinazioneNodeRef
  * @param docName
  * @param conversionResult
  * @param props
  */
		final FileInfo nodeFI = fileFolderService.create(destinazioneNodeRef, docName, ContentModel.TYPE_CONTENT);
		final ContentWriter writer = contentService.getWriter(nodeFI.getNodeRef(), ContentModel.PROP_CONTENT, true);
		writer.setMimetype(MimetypeMap.MIMETYPE_PDF);
		writer.guessEncoding();
		writer.putContent(conversionResult);

		// Adds the look for the description
		nodeService.addAspect(nodeFI.getNodeRef(), ContentModel.ASPECT_TITLED, new HashMap<QName, Serializable>());
		// adds the aspect for the metadata
		nodeService.addAspect(nodeFI.getNodeRef(), VigeWSContentModel.DOC_ASPECT, props);

		logger.info("document saved successfully");
	}

	/**
	 * 
	 * @param path
	 * @param model
	 * @return
	 * @throws NoSuchElementException
	 */
	public NodeRef getRegolaDrools(String model) throws NoSuchElementException {

		// the model must be found in the client's folders.
  /**
  * 
  * @param path
  * @param model
  * @return
  * @throws NoSuchElementException
  */
		StringBuilder rootQuerySpec = new StringBuilder("PATH:\"").append(modelliDroolsPath + "/*")
				.append("\" AND (=@cm\\:name:\"").append(model).append(".drl\")");

		ResultSet modelliSpecRS = searchService.query(StoreRef.STORE_REF_WORKSPACE_SPACESSTORE,
				SearchService.LANGUAGE_FTS_ALFRESCO, rootQuerySpec.toString());

		if (modelliSpecRS.length() < 1) {
			logger.error("Replacement rules file not found: " + model);
			modelliSpecRS.close();
			throw new NoSuchElementException("Replacement rules file not found: " + model);
		}

		return modelliSpecRS.getNodeRef(0);
	}

	/**
	 * It parses the json
	 * 
	 * @param codice
	 * @param json
	 * @return a key-value map with key = concatenation of the separate path by ':'
	 *         value
	 */
	@SuppressWarnings("unchecked")
 /**
 * It parses the json
 * 
 * @param codice
 * @param json
 * @return a key-value map with key = concatenation of the separate path by ':'
 *         value
 */
	public Map<String, String> parseJsonObject(String codice, JSONObject json) {

  /**
  * 
  * @param codice
  * @param jsonArray
  * @return
  */
		Map<String, String> parsedJsonResult = new HashMap<>();

		Set<String> keyset = json.keySet();

		for (String key : keyset) {

			String nuovoCodice = codice + ":" + key;

			Object obj = json.get(key);
			if (obj instanceof JSONObject) {
				// Recursive step
				Map<String, String> parsedJson = parseJsonObject(nuovoCodice, (JSONObject) obj);
				parsedJsonResult.putAll(parsedJson);
			} else if (obj instanceof JSONArray) {
				// Recursive step
				JSONArray valueArray = (JSONArray) obj;
				parseJsonArray(nuovoCodice, valueArray);
			} else if (obj instanceof String) {
				// Base step
				parsedJsonResult.put(nuovoCodice, (String) obj);
			}
		}

		return parsedJsonResult;
	}

	/**
	 * 
	 * @param codice
	 * @param jsonArray
	 * @return
	 */
	public Map<String, String> parseJsonArray(String codice, JSONArray jsonArray) {
  /**
  * 
  * @param codice
  * @param jsonArray
  * @return
  */
		Map<String, String> parsedJsonResult = new HashMap<>();

  /**
  * 
  * @param codice
  * @param jsonArray
  * @return
  */
		for (Object obj : jsonArray) {

			if (obj instanceof JSONObject) {
				Map<String, String> parsedJson = parseJsonObject(codice, (JSONObject) obj);
				parsedJsonResult.putAll(parsedJson);
			} else if (obj instanceof JSONArray) {
				parseJsonArray(codice, (JSONArray) obj);
			} else if (obj instanceof String) {
				// Base step
				parsedJsonResult.put(codice, (String) obj);
			}
		}

		return parsedJsonResult;
	}

	/**
	 * 
	 * @param pdfStream
	 * @return
	 * @throws IOException
	 * @throws COSVisitorException
	 */
	private InputStream setPDFMetadata(InputStream pdfStream) throws IOException {

  /**
  * Set PDF metadata.
  *
  * @param pdfStream the pdf stream
  * @return the input stream
  * @throws IOException the io exception
  */
		PDDocument doc = PDDocument.load(pdfStream);
  /**
  * Set PDF metadata.
  *
  * @param pdfStream the pdf stream
  * @return the input stream
  * @throws IOException the io exception
  */
		PDDocumentInformation info = doc.getDocumentInformation();

		info.setProducer("Sample Bank - http://www.vige.it/");

		doc.setDocumentInformation(info);

		ByteArrayOutputStream out = new ByteArrayOutputStream();

		doc.save(out);

		return new ByteArrayInputStream(out.toByteArray());
	}

 /**
 * Get search service.
 *
 * @return the search service
 */
	public SearchService getSearchService() {
		return searchService;
	}

 /**
 * Set search service.
 *
 * @param searchService the search service
 */
	public void setSearchService(SearchService searchService) {
		this.searchService = searchService;
	}

 /**
 * Get file folder service.
 *
 * @return the file folder service
 */
	public FileFolderService getFileFolderService() {
		return fileFolderService;
	}

 /**
 * Set file folder service.
 *
 * @param fileFolderService the file folder service
 */
	public void setFileFolderService(FileFolderService fileFolderService) {
		this.fileFolderService = fileFolderService;
	}

 /**
 * Get content service.
 *
 * @return the content service
 */
	public ContentService getContentService() {
		return contentService;
	}

 /**
 * Set content service.
 *
 * @param contentService the content service
 */
	public void setContentService(ContentService contentService) {
		this.contentService = contentService;
	}

 /**
 * Get node service.
 *
 * @return the node service
 */
	public NodeService getNodeService() {
		return nodeService;
	}

 /**
 * Set node service.
 *
 * @param nodeService the node service
 */
	public void setNodeService(NodeService nodeService) {
		this.nodeService = nodeService;
	}

 /**
 * Get modelli gen path.
 *
 * @return the string
 */
	public String getModelliGenPath() {
		return modelliGenPath;
	}

 /**
 * Set modelli gen path.
 *
 * @param modelliGenPath the modelli gen path
 */
	public void setModelliGenPath(String modelliGenPath) {
		this.modelliGenPath = modelliGenPath;
	}

 /**
 * Get modelli root path.
 *
 * @return the string
 */
	public String getModelliRootPath() {
		return modelliRootPath;
	}

 /**
 * Set modelli root path.
 *
 * @param modelliRootPath the modelli root path
 */
	public void setModelliRootPath(String modelliRootPath) {
		this.modelliRootPath = modelliRootPath;
	}

 /**
 * Get questions path.
 *
 * @return the string
 */
	public String getQuestionsPath() {
		return questionsPath;
	}

 /**
 * Set questions path.
 *
 * @param questionsPath the questions path
 */
	public void setQuestionsPath(String questionsPath) {
		this.questionsPath = questionsPath;
	}

 /**
 * Get modelli drools path.
 *
 * @return the string
 */
	public String getModelliDroolsPath() {
		return modelliDroolsPath;
	}

 /**
 * Set modelli drools path.
 *
 * @param modelliDroolsPath the modelli drools path
 */
	public void setModelliDroolsPath(String modelliDroolsPath) {
		this.modelliDroolsPath = modelliDroolsPath;
	}

 /**
 * Get auto generated name.
 *
 * @return the string
 */
	public String getAutoGeneratedName() {
		return autoGeneratedName;
	}

 /**
 * Set auto generated name.
 *
 * @param autoGeneratedName the auto generated name
 */
	public void setAutoGeneratedName(String autoGeneratedName) {
		this.autoGeneratedName = autoGeneratedName;
	}

 /**
 * Get xml envelope.
 *
 * @return the string
 */
	public String getXmlEnvelope() {
		return xmlEnvelope;
	}

 /**
 * Set xml envelope.
 *
 * @param xmlEnvelope the xml envelope
 */
	public void setXmlEnvelope(String xmlEnvelope) {
		this.xmlEnvelope = xmlEnvelope;
	}
}
